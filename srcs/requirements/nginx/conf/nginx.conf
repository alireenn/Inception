server {
	listen 80;
	listen [::]:80;

	server_name	$(USER_42).42.fr www.$(USER_42).42.fr;

	return 301 https://$host$request_uri;
	#https://linuxize.com/post/redirect-http-to-https-in-nginx/ link utile per capire questo primo blocco server
}

server {
	listen 443 ssl;
	listen [::]:443 ssl;

	server_name $(USER_42).42.fr www.$(USER_42).42.fr;

	error_log /var/log/custom_logs/nginx/error.log;
	access_log /var/log/custom_logs/nginx/error.log;

	ssl_certificate     /etc/nginx/ssl/inception.crt;
	ssl_certificate_key /etc/nginx/ssl/inception.key;
	ssl_protocols       TLSv1.2 TLSv1.3;

	root /var/www/html;
    index index.html;
	# se viene effettuata una richiesta HTTP a un file o a una directory,
	# Nginx cercherà nella directory "root" specificata (in questo caso, /var/www/html) 
	# e servirà il file richiesto se esiste.
	location / {
		autoindex on;
		try_files = $uri $uri/ =404;
	}

# fastcgi_split_path_info ^(.+\.php)(/.+)$;: Questa riga suddivide l'URI della richiesta in due parti separate: 
# il percorso del file PHP richiesto e la stringa di query (se presente). Questo è necessario perché il parametro SCRIPT_FILENAME 
# passato al server PHP richiede il percorso completo del file PHP richiesto, mentre la stringa di query deve essere passata come parametro separato.
	location ~ \.php$ {
		fastcgi_split_path_info ^(.+\.php)(/.+)$; # splitta la richiesta
		fastcgi_pass wordpress:9000; # pecifica l'indirizzo IP(che si prende da "wordpress") e la porta del server a cui inoltrare la richiesta
		fastcgi_index index.php; # da quello che ho capito è tipo un tryfiles
		include fastcgi_params; # include la libreria che serve nelle righe dopo 
		fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; # percorso completo del file PHP richiesto, 
		# che viene creato concatenando la variabile Nginx $document_root e $fastcgi_script_name
		fastcgi_param PATH_INFO $fastcgi_path_info; # info specifiche della path che prende dalla variabile $fastcgi_path_info
	}
}
